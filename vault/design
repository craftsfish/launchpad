公司间共享货物和资金可以互通有无，可以提高资源利用效率，减少运营成本，提升盈利能力。
在设计上借鉴仓库的概念提出钱包的概念，用于存放资金。
资金账户增加一个钱包属性，属于同一个钱包的资金可以合并利用，只要钱包有资金可以动用，就可以为相关的公司付款。
1)仓库和钱包要不要分开定义？继承自同一基类？
	基于问题3,选择区分定义
2)资金和物资要不要分开定义？继承自同一基类？
	基于问题3,选择区分定义
3)要不要区分资金账户和物资账户？继承自同一基类?
	区分,资金账户属于某个钱包,物资账户属于某个仓库.这样就要求钱包和仓库分开定义.
	如果不区分,账户拥有容器属性和物品属性，隐含要求仓库&钱包基于同一基类，货币&物资基于同一基类.
	用户创建账户的时候必须小心的选择容器和存放的物品,以防物资存放到钱包里面，货币存放到仓库里面.
	基于同一基类，split的账户属性定义为该基类，否则需要定义两个不同的split类（资金/物资）.

organization hierarchy
governor, all
director, company
manager, stall
employee, nothing

模块划分: infra, model, turbine, platform, view, synchronization, analysis, report, visualization

primary key用uuid来标识，避免了int的数量限制，规避了id hacking的风险，适用于account, organization
物资(Article) = 资金(Currency) + 货物(Commodity)
变动采用整型，资金精确到分
时间采用utc存储，便于比较

Supplier {
	uuid
	name
	peroid
}
Wallet {
	uuid
	name
}
Repository {
	uuid
	name
}
Article {
	uuid
	name
}
Commodity {
	supplier
	value
	inproduction
	obsolete
	calibration
	wrap
	proxy
	package
}
Currency {
}
Account {
	uuid
	name
	category
	balance
	organization
}
CurrencyAccount(Account) {
	currency
	wallet
	unique_together = ("organization", "currency", "category", "wallet", "name")
}
CommodityAccount(Account) {
	commodity
	repository
	unique_together = ("organization", "commodity", "category", "repository", "name")
}
Task {
	desc
}
Transaction {
	desc
	task
	time
}
ShipTransaction(Transaction) {
	invoice #发货清单编号
	pid #平台编号
}
Split {
	account
	change
	transaction
}
abstract:Order(Task) {
	time = models.DateTimeField(default=timezone.now)
	repository
	sale
}
abstract:FakeOrder {
	counterfeit
	counterfeit_auto_clear
	delivery
	recall
	recall_repository
}
JdOrder(Order) {
	oid
	status
}
JdFakeOrder(JdOrder, FakeOrder) {
	pass
}
TmOrder(Order) {
	oid
	status
}
TmFakeOrder(TmOrder, FakeOrder) {
	pass
}
